<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Spring Web Services | Neojal Github Site</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Spring Web Services" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Spring Web Services @Controller Creates a Map of model objects and finds a View (html). So, it’s used to display HTML contents. Is a specialization of @Component. @RequestBody Maps the HttpRequest body to a domain object: deserializes the inbound HttpRequest body onto a Java object. @ResponseBody Tells a Controller that the object returned is automatically serialized into JSON and passed back into the HttpResponse object. @RestController Is a combination of @Controller and @ResponseBody. Automatically serializes return objects into HttpResponse. @RequestMapping(method = RequestMethod.GET, path = “/my-rest-controller”) Maps an HTTP Get request to a method. It can be replaced for the next Mapping annotations. @GetMapping(path = “/my-path”) @PostMapping(path = “/my-path”) @PutMapping(path = “/my-path”) @PathVariable @Component and its variants @Autowired URI and ResponseEntity classes /** * * @param user * @return a ResponseEntity with headers: * HTTP 201 created code: HTTP/1.1 201 * location of the new resource: Location: http://localhost:8080/users/4 * of the new resource. */ @PostMapping(path = &quot;/users&quot;) public ResponseEntity&lt;Object&gt; createUser(@RequestBody User user) { User createdUser = userDaoService.save(user); URI location = ServletUriComponentsBuilder .fromCurrentRequest() .path(&quot;/{id}&quot;) .buildAndExpand(createdUser.getId()).toUri(); return ResponseEntity.created(location).build(); } @ResponseStatus(code = HttpStatus.NOT_FOUND) Using @ResponseStatusCode in an Unchecked Exception (RunTime Exception) thrown in a Controller: @ResponseStatus(code = HttpStatus.NOT_FOUND) public class UserNotFoundException extends RuntimeException { public UserNotFoundException(String message) { super(message); } } Response: Structure, fields, of the response are provided by Spring by default. ´´´ HTTP/1.1 404 Content-Type: application/json Transfer-Encoding: chunked Date: Tue, 03 Dec 2019 01:33:20 GMT { “timestamp”: “2019-12-03T01:33:20.234+0000”, “status”: 404, “error”: “Not Found”, “message”: “id = 5”, “trace”: “com.neojal.restfulwebservices.user”, “path”: “/users/5” } ´´´ ResponseEntityExceptionHandler abstract class (Spring) It is possible to create a customized error response structure by extending and implementing the methods defined in such class, as well as using @ControllerAdvice and @RestController in such class, as follows: ´´´java @ControllerAdvice @RestController public class CustomizedResponseEntityExceptionHandler extends ResponseEntityExceptionHandler { @ExceptionHandler(Exception.class) public final ResponseEntity&lt;Object&gt; handleAllExceptions(Exception ex, WebRequest request) { ExceptionResponse exceptionResponse = new ExceptionResponse( new Date(), ex.getMessage(), request.getDescription(false)); return new ResponseEntity(exceptionResponse, HttpStatus.INTERNAL_SERVER_ERROR); } @ExceptionHandler(UserNotFoundException.class) public final ResponseEntity&lt;Object&gt; handleUserNotFoundExceptions(Exception ex, WebRequest request) { ExceptionResponse exceptionResponse = new ExceptionResponse( new Date(), ex.getMessage(), request.getDescription(false)); return new ResponseEntity(exceptionResponse, HttpStatus.NOT_FOUND); } @Override protected ResponseEntity&lt;Object&gt; handleMethodArgumentNotValid(MethodArgumentNotValidException ex, HttpHeaders headers, HttpStatus status, WebRequest request) { ExceptionResponse exceptionResponse = new ExceptionResponse( new Date(), &quot;Validation Failed.&quot;, request.getDescription(false)); return new ResponseEntity(exceptionResponse, HttpStatus.BAD_REQUEST); } } ´´´ @ControllerAdvice @Valid (java Validation API) and Hibernate Validator implementation Rest Clients Spring RestTemplate Spring RestTemplate current Spring RestTemplate Synchronous client to perform HTTP requests, exposing a simple, template method API over underlying HTTP client libraries such as the JDK HttpURLConnection, Apache HttpComponents, and others. The RestTemplate offers templates for common scenarios by HTTP method, in addition to the generalized exchange and execute methods that support of less frequent cases." />
<meta property="og:description" content="Spring Web Services @Controller Creates a Map of model objects and finds a View (html). So, it’s used to display HTML contents. Is a specialization of @Component. @RequestBody Maps the HttpRequest body to a domain object: deserializes the inbound HttpRequest body onto a Java object. @ResponseBody Tells a Controller that the object returned is automatically serialized into JSON and passed back into the HttpResponse object. @RestController Is a combination of @Controller and @ResponseBody. Automatically serializes return objects into HttpResponse. @RequestMapping(method = RequestMethod.GET, path = “/my-rest-controller”) Maps an HTTP Get request to a method. It can be replaced for the next Mapping annotations. @GetMapping(path = “/my-path”) @PostMapping(path = “/my-path”) @PutMapping(path = “/my-path”) @PathVariable @Component and its variants @Autowired URI and ResponseEntity classes /** * * @param user * @return a ResponseEntity with headers: * HTTP 201 created code: HTTP/1.1 201 * location of the new resource: Location: http://localhost:8080/users/4 * of the new resource. */ @PostMapping(path = &quot;/users&quot;) public ResponseEntity&lt;Object&gt; createUser(@RequestBody User user) { User createdUser = userDaoService.save(user); URI location = ServletUriComponentsBuilder .fromCurrentRequest() .path(&quot;/{id}&quot;) .buildAndExpand(createdUser.getId()).toUri(); return ResponseEntity.created(location).build(); } @ResponseStatus(code = HttpStatus.NOT_FOUND) Using @ResponseStatusCode in an Unchecked Exception (RunTime Exception) thrown in a Controller: @ResponseStatus(code = HttpStatus.NOT_FOUND) public class UserNotFoundException extends RuntimeException { public UserNotFoundException(String message) { super(message); } } Response: Structure, fields, of the response are provided by Spring by default. ´´´ HTTP/1.1 404 Content-Type: application/json Transfer-Encoding: chunked Date: Tue, 03 Dec 2019 01:33:20 GMT { “timestamp”: “2019-12-03T01:33:20.234+0000”, “status”: 404, “error”: “Not Found”, “message”: “id = 5”, “trace”: “com.neojal.restfulwebservices.user”, “path”: “/users/5” } ´´´ ResponseEntityExceptionHandler abstract class (Spring) It is possible to create a customized error response structure by extending and implementing the methods defined in such class, as well as using @ControllerAdvice and @RestController in such class, as follows: ´´´java @ControllerAdvice @RestController public class CustomizedResponseEntityExceptionHandler extends ResponseEntityExceptionHandler { @ExceptionHandler(Exception.class) public final ResponseEntity&lt;Object&gt; handleAllExceptions(Exception ex, WebRequest request) { ExceptionResponse exceptionResponse = new ExceptionResponse( new Date(), ex.getMessage(), request.getDescription(false)); return new ResponseEntity(exceptionResponse, HttpStatus.INTERNAL_SERVER_ERROR); } @ExceptionHandler(UserNotFoundException.class) public final ResponseEntity&lt;Object&gt; handleUserNotFoundExceptions(Exception ex, WebRequest request) { ExceptionResponse exceptionResponse = new ExceptionResponse( new Date(), ex.getMessage(), request.getDescription(false)); return new ResponseEntity(exceptionResponse, HttpStatus.NOT_FOUND); } @Override protected ResponseEntity&lt;Object&gt; handleMethodArgumentNotValid(MethodArgumentNotValidException ex, HttpHeaders headers, HttpStatus status, WebRequest request) { ExceptionResponse exceptionResponse = new ExceptionResponse( new Date(), &quot;Validation Failed.&quot;, request.getDescription(false)); return new ResponseEntity(exceptionResponse, HttpStatus.BAD_REQUEST); } } ´´´ @ControllerAdvice @Valid (java Validation API) and Hibernate Validator implementation Rest Clients Spring RestTemplate Spring RestTemplate current Spring RestTemplate Synchronous client to perform HTTP requests, exposing a simple, template method API over underlying HTTP client libraries such as the JDK HttpURLConnection, Apache HttpComponents, and others. The RestTemplate offers templates for common scenarios by HTTP method, in addition to the generalized exchange and execute methods that support of less frequent cases." />
<link rel="canonical" href="/web-services/spring-web-services.html" />
<meta property="og:url" content="/web-services/spring-web-services.html" />
<meta property="og:site_name" content="Neojal Github Site" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-04-21T18:18:13-05:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Spring Web Services" />
<script type="application/ld+json">
{"@type":"BlogPosting","description":"Spring Web Services @Controller Creates a Map of model objects and finds a View (html). So, it’s used to display HTML contents. Is a specialization of @Component. @RequestBody Maps the HttpRequest body to a domain object: deserializes the inbound HttpRequest body onto a Java object. @ResponseBody Tells a Controller that the object returned is automatically serialized into JSON and passed back into the HttpResponse object. @RestController Is a combination of @Controller and @ResponseBody. Automatically serializes return objects into HttpResponse. @RequestMapping(method = RequestMethod.GET, path = “/my-rest-controller”) Maps an HTTP Get request to a method. It can be replaced for the next Mapping annotations. @GetMapping(path = “/my-path”) @PostMapping(path = “/my-path”) @PutMapping(path = “/my-path”) @PathVariable @Component and its variants @Autowired URI and ResponseEntity classes /** * * @param user * @return a ResponseEntity with headers: * HTTP 201 created code: HTTP/1.1 201 * location of the new resource: Location: http://localhost:8080/users/4 * of the new resource. */ @PostMapping(path = &quot;/users&quot;) public ResponseEntity&lt;Object&gt; createUser(@RequestBody User user) { User createdUser = userDaoService.save(user); URI location = ServletUriComponentsBuilder .fromCurrentRequest() .path(&quot;/{id}&quot;) .buildAndExpand(createdUser.getId()).toUri(); return ResponseEntity.created(location).build(); } @ResponseStatus(code = HttpStatus.NOT_FOUND) Using @ResponseStatusCode in an Unchecked Exception (RunTime Exception) thrown in a Controller: @ResponseStatus(code = HttpStatus.NOT_FOUND) public class UserNotFoundException extends RuntimeException { public UserNotFoundException(String message) { super(message); } } Response: Structure, fields, of the response are provided by Spring by default. ´´´ HTTP/1.1 404 Content-Type: application/json Transfer-Encoding: chunked Date: Tue, 03 Dec 2019 01:33:20 GMT { “timestamp”: “2019-12-03T01:33:20.234+0000”, “status”: 404, “error”: “Not Found”, “message”: “id = 5”, “trace”: “com.neojal.restfulwebservices.user”, “path”: “/users/5” } ´´´ ResponseEntityExceptionHandler abstract class (Spring) It is possible to create a customized error response structure by extending and implementing the methods defined in such class, as well as using @ControllerAdvice and @RestController in such class, as follows: ´´´java @ControllerAdvice @RestController public class CustomizedResponseEntityExceptionHandler extends ResponseEntityExceptionHandler { @ExceptionHandler(Exception.class) public final ResponseEntity&lt;Object&gt; handleAllExceptions(Exception ex, WebRequest request) { ExceptionResponse exceptionResponse = new ExceptionResponse( new Date(), ex.getMessage(), request.getDescription(false)); return new ResponseEntity(exceptionResponse, HttpStatus.INTERNAL_SERVER_ERROR); } @ExceptionHandler(UserNotFoundException.class) public final ResponseEntity&lt;Object&gt; handleUserNotFoundExceptions(Exception ex, WebRequest request) { ExceptionResponse exceptionResponse = new ExceptionResponse( new Date(), ex.getMessage(), request.getDescription(false)); return new ResponseEntity(exceptionResponse, HttpStatus.NOT_FOUND); } @Override protected ResponseEntity&lt;Object&gt; handleMethodArgumentNotValid(MethodArgumentNotValidException ex, HttpHeaders headers, HttpStatus status, WebRequest request) { ExceptionResponse exceptionResponse = new ExceptionResponse( new Date(), &quot;Validation Failed.&quot;, request.getDescription(false)); return new ResponseEntity(exceptionResponse, HttpStatus.BAD_REQUEST); } } ´´´ @ControllerAdvice @Valid (java Validation API) and Hibernate Validator implementation Rest Clients Spring RestTemplate Spring RestTemplate current Spring RestTemplate Synchronous client to perform HTTP requests, exposing a simple, template method API over underlying HTTP client libraries such as the JDK HttpURLConnection, Apache HttpComponents, and others. The RestTemplate offers templates for common scenarios by HTTP method, in addition to the generalized exchange and execute methods that support of less frequent cases.","headline":"Spring Web Services","dateModified":"2021-04-21T18:18:13-05:00","datePublished":"2021-04-21T18:18:13-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"/web-services/spring-web-services.html"},"url":"/web-services/spring-web-services.html","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Neojal Github Site" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Neojal Github Site</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Spring Web Services</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2021-04-21T18:18:13-05:00" itemprop="datePublished">Apr 21, 2021
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="spring-web-services">Spring Web Services</h1>

<h2 id="controller">@Controller</h2>

<p>Creates a Map of model objects and finds a View (html). So, it’s used to display HTML
contents. Is a specialization of @Component.</p>

<h2 id="requestbody">@RequestBody</h2>

<p>Maps the HttpRequest body to a domain object: deserializes the inbound HttpRequest body 
onto a Java object.</p>

<h2 id="responsebody">@ResponseBody</h2>

<p>Tells a Controller that the object returned is automatically serialized into JSON and
passed back into the HttpResponse object.</p>

<h2 id="restcontroller">@RestController</h2>

<p>Is a combination of @Controller and @ResponseBody. Automatically serializes return
objects into HttpResponse.</p>

<h2 id="requestmappingmethod--requestmethodget-path--my-rest-controller">@RequestMapping(method = RequestMethod.GET, path = “/my-rest-controller”)</h2>

<p>Maps an HTTP Get request to a method. It can be replaced for the next Mapping annotations.</p>

<h2 id="getmappingpath--my-path">@GetMapping(path = “/my-path”)</h2>
<h2 id="postmappingpath--my-path">@PostMapping(path = “/my-path”)</h2>
<h2 id="putmappingpath--my-path">@PutMapping(path = “/my-path”)</h2>

<h2 id="pathvariable">@PathVariable</h2>

<h2 id="component-and-its-variants">@Component and its variants</h2>

<h2 id="autowired">@Autowired</h2>

<h2 id="uri-and-responseentity-classes">URI and ResponseEntity classes</h2>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
    <span class="cm">/**
     * 
     * @param user
     * @return a ResponseEntity with headers:
     *      HTTP 201 created code: HTTP/1.1 201 
     *      location of the new resource: Location: http://localhost:8080/users/4
     * of the new resource.
     */</span>
    <span class="nd">@PostMapping</span><span class="o">(</span><span class="n">path</span> <span class="o">=</span> <span class="s">"/users"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">ResponseEntity</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="nf">createUser</span><span class="o">(</span><span class="nd">@RequestBody</span>  <span class="nc">User</span> <span class="n">user</span><span class="o">)</span> <span class="o">{</span>

        <span class="nc">User</span> <span class="n">createdUser</span> <span class="o">=</span> <span class="n">userDaoService</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">user</span><span class="o">);</span>

        <span class="no">URI</span> <span class="n">location</span> <span class="o">=</span> <span class="nc">ServletUriComponentsBuilder</span>
                <span class="o">.</span><span class="na">fromCurrentRequest</span><span class="o">()</span>
                <span class="o">.</span><span class="na">path</span><span class="o">(</span><span class="s">"/{id}"</span><span class="o">)</span>
                <span class="o">.</span><span class="na">buildAndExpand</span><span class="o">(</span><span class="n">createdUser</span><span class="o">.</span><span class="na">getId</span><span class="o">()).</span><span class="na">toUri</span><span class="o">();</span>

        <span class="k">return</span> <span class="nc">ResponseEntity</span><span class="o">.</span><span class="na">created</span><span class="o">(</span><span class="n">location</span><span class="o">).</span><span class="na">build</span><span class="o">();</span>
    <span class="o">}</span>

</code></pre></div></div>

<h2 id="responsestatuscode--httpstatusnot_found">@ResponseStatus(code = HttpStatus.NOT_FOUND)</h2>

<ul>
  <li>Using @ResponseStatusCode in an Unchecked Exception (RunTime Exception) 
thrown in a Controller:</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nd">@ResponseStatus</span><span class="o">(</span><span class="n">code</span> <span class="o">=</span> <span class="nc">HttpStatus</span><span class="o">.</span><span class="na">NOT_FOUND</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserNotFoundException</span> <span class="kd">extends</span> <span class="nc">RuntimeException</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="nf">UserNotFoundException</span><span class="o">(</span><span class="nc">String</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>
            <span class="kd">super</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>Response: Structure, fields, of the response are provided by Spring by default.</li>
</ul>

<p>´´´
HTTP/1.1 404 
Content-Type: application/json
Transfer-Encoding: chunked
Date: Tue, 03 Dec 2019 01:33:20 GMT</p>

<p>{
  “timestamp”: “2019-12-03T01:33:20.234+0000”,
  “status”: 404,
  “error”: “Not Found”,
  “message”: “id = 5”,
  “trace”: “com.neojal.restfulwebservices.user”,
  “path”: “/users/5”
}
´´´</p>

<h2 id="responseentityexceptionhandler-abstract-class-spring">ResponseEntityExceptionHandler abstract class (Spring)</h2>

<p>It is possible to create a customized error response structure by extending and
implementing the methods defined in such class, as well as using @ControllerAdvice
and @RestController in such class, as follows:</p>

<p>´´´java
@ControllerAdvice
@RestController
public class CustomizedResponseEntityExceptionHandler
        extends ResponseEntityExceptionHandler {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@ExceptionHandler(Exception.class)
public final ResponseEntity&lt;Object&gt; handleAllExceptions(Exception ex, WebRequest request) {

    ExceptionResponse exceptionResponse =
            new ExceptionResponse(
                    new Date(), ex.getMessage(), request.getDescription(false));

    return new ResponseEntity(exceptionResponse, HttpStatus.INTERNAL_SERVER_ERROR);
}

@ExceptionHandler(UserNotFoundException.class)
public final ResponseEntity&lt;Object&gt; handleUserNotFoundExceptions(Exception ex, WebRequest request) {

    ExceptionResponse exceptionResponse =
            new ExceptionResponse(
                    new Date(), ex.getMessage(), request.getDescription(false));

    return new ResponseEntity(exceptionResponse, HttpStatus.NOT_FOUND);
}

@Override
protected ResponseEntity&lt;Object&gt; handleMethodArgumentNotValid(MethodArgumentNotValidException ex, HttpHeaders headers, HttpStatus status, WebRequest request) {

    ExceptionResponse exceptionResponse =
            new ExceptionResponse(
                    new Date(), "Validation Failed.", request.getDescription(false));

    return new ResponseEntity(exceptionResponse, HttpStatus.BAD_REQUEST);
} } ´´´
</code></pre></div></div>

<h2 id="controlleradvice">@ControllerAdvice</h2>

<h2 id="valid-java-validation-api-and-hibernate-validator-implementation">@Valid (java Validation API) and Hibernate Validator implementation</h2>

<h3 id="rest-clients">Rest Clients</h3>

<h2 id="spring-resttemplate">Spring RestTemplate</h2>

<ul>
  <li><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html">Spring RestTemplate current</a></li>
  <li><a href="https://howtodoinjava.com/spring-boot2/resttemplate/spring-restful-client-resttemplate-example/">Spring RestTemplate</a></li>
</ul>

<p>Synchronous client to perform HTTP requests, exposing a simple, template method API over underlying HTTP client libraries such as the JDK HttpURLConnection, Apache HttpComponents, and others.</p>

<p>The RestTemplate offers templates for common scenarios by HTTP method, in addition to the generalized exchange and execute methods that support of less frequent cases.</p>

  </div><a class="u-url" href="/web-services/spring-web-services.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

<!--
    <h2 class="footer-heading">Neojal Github Site</h2>
    <a class="footer-heading" rel="author" href="/">Neojal Github Site</a>
-->

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Neojal Github Site
            </li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/neojal"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">neojal</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Software Engineering, related topics and tools.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
